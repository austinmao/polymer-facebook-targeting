<dom-module id="reach-estimate">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }
      .error {font-size: 10px; color:red; margin-top: 5px;}
      #toast {background: red; color: white;}
    </style>
    <div>
      Users: <span>{{data.users}}</span>&nbsp;&nbsp;
      CPA:<span>{{data.cpa_median}}</span>&nbsp;&nbsp;
      CPC:<span>{{data.cpc_median}}</span>&nbsp;&nbsp;
      CPM:<span>{{data.cpm_median}}</span>&nbsp;&nbsp;
    </div>
    <iron-ajax id="ajax" auto handle-as="json" last-response="{{_ajaxResponse}}" on-response="_handleAjaxResponse" on-error="_handleAjaxError"></iron-ajax>
    <paper-toast id="toast" text="{{error}}" duration="5000"></paper-toast>
  </template>

  <script>
    class ReachEstimate {
      beforeRegister() {
        this.is = 'reach-estimate';
        this.properties = {
          config: {
            type: Object
          },
          targetingSpec: {
            type: Object,
            reflectToAttribute: true,
            notify: true
          }
        };
        this.observers = ['_targetingSpecChanged(targetingSpec.*)'];
      }
      _targetingSpecChanged() {
        this.targetingSpecForReachEstimate = {
          'geo_locations': {
                'countries': [],
                'cities': [],
                'regions': [],
                'zips':[]
              },
          'excluded_geo_locations': {
            'countries': [],
            'cities': [],
            'regions': [],
            'zips':[]
          }
        };

        let added = false;
        for(let prop in this.targetingSpec) {
          if(prop === 'geo_locations' || prop === 'excluded_geo_locations') {
            this.targetingSpec[prop].map( e => {
              switch (e.type) {
                case 'city':
                  this.targetingSpecForReachEstimate[prop]['cities'].push({'key': e.key}); added = true; break;
                case 'country':
                  this.targetingSpecForReachEstimate[prop]['countries'].push(e.key); added = true; break;
                case 'region':
                  this.targetingSpecForReachEstimate[prop]['regions'].push({'key': e.key}); added = true; break;
                case 'zip':
                  this.targetingSpecForReachEstimate[prop]['zips'].push({'key': e.key}); added = true; break;
              }
            });
          }
          // case for others
          // demographics, interests
        }
        if(!added) {
          this.data = {};
          return;
        }
        this.error = null;
        this._handleAjax();
      }

      _handleAjax() {
        let params = {
          'targeting_spec': JSON.stringify(this.targetingSpecForReachEstimate),
          'access_token': this.config.access_token
        };
        let url=`https://graph.facebook.com/v2.4/${this.config.account}/reachestimate`;
        if(this.targetingSpec) {
          this.$.ajax.params = params;
          this.$.ajax.url = url;
        }
      }
      _handleAjaxResponse(res) {
        if(res.detail.xhr.response) {
          let data = res.detail.xhr.response;
          this.data = {
            users: data.users.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '.'),
            cpa_median: data.data.bid_estimations[0].cpa_median / 100,
            cpc_median: data.data.bid_estimations[0].cpc_median / 100,
            cpm_median: data.data.bid_estimations[0].cpm_median / 100,
          };
        }
      }
      _handleAjaxError(ev,obj) {
        this.error = obj.request.xhr.response.error.message;
        if(obj.request.xhr.response.error.message === 'Invalid parameter') {
          this.error += ': ' + obj.request.xhr.response.error.error_user_title;
        }
        this.$.toast.show();
      }
    }

    Polymer(ReachEstimate);
  </script>

</dom-module>
